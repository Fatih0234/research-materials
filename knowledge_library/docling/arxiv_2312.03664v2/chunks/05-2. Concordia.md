## 2. Concordia

Like other agent-based modeling approaches, a generative model of social interactions (i.e. a GABM) consists of two parts: the model of the environment and the model of individual behavior. In this case both are generative. Thus we have: (a) a set of generative agents and (b) a generative model for the setting and context of the social

2 here: https://github.com/google-deepmind/ concordia

Figure 2 | The above example illustrates the working memory z of an agent with 3 components (identity, plan, observation-and-clock). The identity component itself has several sub-components (core characteristics, daily occupation, feeling about progress in life). Together they condition the LLM call to elicit the behavioral response (i.e. produced in response to the final question asking what Alice will do next.).

<!-- image -->

interaction i.e. the environment, space, or world where the interaction takes place. We call the model responsible for the environment the Game Master (GM). Both this name and the approach it reflects were inspired by table-top role-playing games like Dungeons and Dragons where a player called the Game Master takes the role of the storyteller (Gygax and Cook, 1989). In these games, players interact with one another and with nonplayer characters in a world invented and maintained by the GM.

Concordia agents consume observations and produce actions. The GM consumes agent actions and creates event statements , which define what has happened in the simulation as a result of the agent's attempted action. Figure 1 illustrates this setup. The GM also creates and sends observations to agents. Observations, actions and event statements are all strings in English. The GM is also responsible for maintaining and updating grounded variables, advancing the clock and running the episode loop.

Concordia agents generate their behavior by describing what they intend to do in natural language-e.g. 'Alex makes breakfast'. The game master takes their intended actions, decides on the outcome of their attempt, and generates event statements. The GM is responsible for:

1. Maintaining a consistent and grounded state of the world where agents interact with each other.
2. Communicating the observable state of the world to the agents.
3. Deciding the effect of agents' actions on the world and each other.
4. Resolving what happens when actions submitted by multiple agents conflict with one another.

The most important responsibility of the GM is to provide the grounding for particular experimental variables, which are defined on a perexperiment basis. The GM determines the effect of the agents' actions on these variables, records them, and checks that they are valid. Whenever an agent tries to perform an action that violates the grounding, it communicates to them that their action was invalid. For example, in an economic simulation the amount of money in an agent's possession may be a grounded variable. The GM would track whether agents gained or lost money

on each step and perhaps prevent them from paying more than they have available.

One may configure the specific set of grounded variables to use on a per-experiment basis. This flexible functionality is critical because different research applications require different variables.

You can take a look at an example output of one of our experiments (see the Concordia GitHub repo), which was simulating elections in a small town, where some agents are running for mayor and one other is running a smear campaign against a candidate.
