## A.3. GM components

Game Master components implement the following methods:

1. .name() -returns the name of the components, for example "location of players";
2. .state() -returns the state of the component ùëß ùëñ , for example "Alice is at the pub; Bob is at the gas station";
3. .partial\_state(player\_name) -state of the component to expose to the player. For example, location component would only expose the location of the player to themselves, but not the location of others.
4. .update() -updates the state of the component by implementing; eq. (2);
5. .update\_before\_event(cause\_statement) -update the component state before the event statement from the cause, which is the players action i.e. "Bob calls Alice.";
6. .update\_after\_event(event\_statement) -update the component state directly from the event statement. For example "Bob called Alice, but she didn't respond.";
7. terminate\_episode() -if component returns true, the GM will terminate the episode.

One step of environment consists of GMs interactions with each player, which are arranged in a (random) initiative order. The GM advances the clock either after each or all the players make take their actions 9 . To process the players action, the GM calls the components functions in the following order. First, for each component the GM calls .update , then .partial\_state and sends the output to the agent as an observation. The GM then calls .act on the player and receives the attempted action and uses it to call .update\_before\_event . Now GM can construct its context by calling .state on the components. GM then executes the chain of thought to create the event statement. After that it calls .update\_after\_event on all components. As the last step, GM calls terminate\_episode and if any of the components returns True, the episode is terminated.

In Concordia all custom functionality is implemented through components. For grounded

9 Controlled by a flag in the GM constructor.

variables, which are tracked in Python, a specialised component is created to maintain the variable's state, update it after relevant events, and represent it to the GM in linguistic form ùëß ùëñ . Similarly, components can send observations to players. For example, a component during the .update\_after\_event call might check if the event was observed by, or has effect on, other players apart from the acting player. Some components, like player status and location, send an observation to the player before it is their turn to act by implementing .partial\_state .

GM components can also be built around classical (non LLM) modelling tools like differential equations, finite state machines and so on. The only requirement is that they can represent their state in language. We can also wire different classic simulators together using natural language as the 'glue'.
